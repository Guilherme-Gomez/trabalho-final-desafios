---
title: "Desafios e Requisitos dos Projetos Analiticos"
authores: "Davi Almeida Ferreira e Guilherme Rocha Gomez"
date: "Julho de 2021"
output:
  html_document:
        code_folding: hide
        number_sections: no
        toc: yes
        toc_float:
            collapsed: yes
            smooth_scroll: yes
---
<left>

![](simbolo_fgv.png)

Turma: **FGV TBABD-8**  
Professor: **Rafael Lychowski**  
Autores: **Davi Almeida Ferreira**,
        **Jucelino Ribeiro Carvalho** e
        **Guilherme Rocha Gomez** 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 10, warning = F, error = F)
```


### Metodologia utilizada

Utilizaremos para a realização deste trabalho a metodologia CRISP-DM

<center>

![](crisp-dm.png)

### Entendimento do Negócio

A Vale pretende prever o desgaste de rodas de vagões e fornecer uma visão futura da frota de rodeiros, para melhor planejamento de menutanção e compra de componentes. 

**Problema:** Prever se o friso da roda estaá abaixo de 26 mm na próxima leitura.

1. A área não tem visibilidade do que vai contecer com o ativos, antecipando as trocas;
2. A cada troca o rodeiro é usinado, e sua vida útil reduzida;
3. Incapacidade de visuzalização de desgastes acelerados em toda a frota de vagões
4. Muitos vagões apresentam reinciência de trocas, e os fatores não são bem claros;

* Base de dados: EFC_WAYSIDES.csv
* Variável dependente: ESPESSURA_FRISO_RODA
* Método: Supervisionado
* Submétodo: Classificação
* Objetivo: Identificar quais os frisos terão menos que 26 cm de friso no próximo ciclo.

### Entendimento dos Dados

```{r include=FALSE}
# Importar bibliotecas que serão utilizadas no trabalho

library(caret)
library(mlbench)
library(dplyr)
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(hrbrthemes)
library(viridis)
library(tseries)
library(ggfortify)

# Iniciar sessão do SPARK
# Separando as mehores configurações para os computadores que cada integrante do grupo usa.

#aluno <- "Guilherme"
#aluno <- "Juscelino"
aluno <- "Davi"

if (aluno == "Guilherme") {

spark_path <-'C:/Guilherme/spark'
if (nchar(Sys.getenv("SPARK_HOME")) < 1) {
  Sys.setenv(SPARK_HOME = spark_path)
}
library(SparkR, lib.loc = c(file.path(Sys.getenv("SPARK_HOME"), "R", "lib")))
sparkR.session(master = "local[*]", sparkConfig = 
list(spark.driver.memory = "1g"))

pathfile = "C:/Guilherme/FGV/Desafios e Requisitos dos Projetos Analiticos/EFC_WAYSIDES.csv"

}else{

library(SparkR)

spark_path <-"C:/spark-3.1.2-bin-hadoop3.2"
if (nchar(Sys.getenv("SPARK_HOME")) < 1) {
  Sys.setenv(SPARK_HOME = spark_path)
}
sparkR.session(master = "local[*]", sparkConfig = list(spark.driver.memory = "6g"))

pathfile <- "C:/trabalho-final-desafios/EFC_WAYSIDES.csv"
}

paste("Configuração para o computador do: ",aluno)

sqlContext <- sparkR.session(sc)
sparkR.conf()

```

```{r include=FALSE}
# Importar dataset 

# Utilizando o inferSchema muitos campos numéricos foram identificados com string.
schema <- structType(
  structField("ROW_ID", "string"),
  structField("DATA_HORA_LEITURA", "timestamp"),
  structField("CODIGO_VAGAO", "string"),
  structField("CODIGO_RODEIRO", "string"),
  structField("CODIGO_RODA", "string"),
  structField("LADO_RODA", "string"),
  structField("EIXO_VAGAO", "double"),
  structField("CICLO_RODEIRO", "string"),
  structField("TRAIN_ID", "string"),
  structField("SENTIDO_TREM", "string"),
  structField("VELOCIDADE_ENTRADA_TREM", "double"),
  structField("VELOCIDADE_SAIDA_TREM", "double"),
  structField("POSICAO_VAGAO_COMPOSICAO", "double"),
  structField("ANGULO_FRISO_RODA", "double"),
  structField("ALTURA_FRISO_RODA", "double"),
  structField("ESPESSURA_FRISO_RODA", "double"),
  structField("CAVA_RODA", "double"),
  structField("ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE", "double"),
  structField("ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE", "double"),
  structField("TRACKING_POSITION_EIXO_FRONTAL_TRUQUE", "double"),
  structField("TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE", "double"),
  structField("ROTACAO_EIXO", "double"),
  structField("ALINHAMENTO_ENTRE_EIXOS_(IAM)", "double"),
  structField("DESLOCAMENTO_ENTRE_EIXOS_(SHIFT)", "double"),
  structField("TRACKING_ERROR_(TE)", "double"),
  structField("SERPENTEAMENTO_(HUNTING)", "double"),
  structField("friso_baixo", "integer"),
  structField("FRISO_MENOR_QUE_26", "integer")
)

df <- SparkR::read.df(path = pathfile,
                      header='true', 
                      source = "com.databricks.spark.csv", 
                      schema = schema,
                      na.strings = "")

head(df)
cache(df)


#Criando novas colunas pelo método mais comum.
df$friso_baixo <- SparkR::ifelse(df$ESPESSURA_FRISO_RODA<26,1,0)

#Criando novas colunas pelo método mais comum.
df$FRISO_MENOR_QUE_26 <- SparkR::ifelse(df$ESPESSURA_FRISO_RODA<26,"YES","NO")

#Criando novas colunas e escolhendo o tipo de dado usanod withColumn.
df <- df %>% 
  withColumn(.,"Dia",cast(df$DATA_HORA_LEITURA,"Date")) #%>% 
  #withColumn(.,"Dia",cast(df$DATA_HORA_LEITURA,"Date"))


df_sample <- df %>% sample(withReplacement = F,fraction = 0.0005)

#read.df(sqlContext,)

# Incluir o arquivo na memória para facilitar a interação
persist(df,"MEMORY_ONLY")

#cache(df) == persist(df,"MEMORY_ONLY")
#cacheTable(sqlContext,"tableNmae")

```

#### Verificação da qualidade dos Dados

```{r}
"Verificando o 'Schema' dos dados"
printSchema(df)

```

##### Verificar a existencia de dados faltantes


```{r include=FALSE}

#Visualizando uma amostra de dados
SparkR::head(df,32)
#dtypes(df)

#Verificando valores faltantes no df
ncol_df <- ncol(df)
ncol_df

columns(df)
col_name <- 0
is_Null <- 0
col_class <- 0

```


```{r, cache=TRUE}

#Verificando qualidade dos dados.
# Davi - modifiquei a função para poder ser utilizada com mais de um data_frame
test_null <- function(data_frame,coluna){
   try(data_frame %>% where(.,isNull(.[[coluna]]))%>%count(.), silent = TRUE)}

test_isNAN <- function(data_frame,coluna){
  try(data_frame %>% where(.,isNaN(.[[coluna]]))%>%count(.), silent = TRUE)}

test_vazio <- function(data_frame,coluna){
  try(data_frame %>% where(.,.[[coluna]]== "")  %>% count(.), silent = TRUE)}

test_zero <- function(data_frame,coluna){
  try(data_frame %>% where(.,.[[coluna]]== 0)  %>% count(.), silent = TRUE)}

total <- count(df)

class(df$ROW_ID)

x <- 0
Tipo_de_dados <- 0

# Criando a coluna de tipo de dados
for (i in 1:length(colnames(df))){
  x[i] <- dtypes(df)[[i]][1]
  Tipo_de_dados[i] <- dtypes(df)[[i]][2]
}
tipo_dados <- as.data.frame(Tipo_de_dados,x)

cont_prob <- data.frame()
for (coluna in colnames(df)){
#As colunas no dataframe serão linhas neste relatório.
  
  cont_prob[coluna,"Nulo"]  <- ifelse(is.numeric(test_null(df,coluna)),test_null(df,coluna),0)
  cont_prob[coluna,"% Nulo"]  <- ifelse(is.numeric(test_null(df,coluna)),
                                        paste(round(((test_null(df,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_prob[coluna,"isNAN"] <-    ifelse(is.numeric(test_isNAN(df,coluna)),test_isNAN(df,coluna),0)
  cont_prob[coluna,"% isNAN"]  <- ifelse(is.numeric(test_isNAN(df,coluna)),
                                        paste(round(((test_isNAN(df,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_prob[coluna,"Vazio"] <- ifelse(is.numeric(test_vazio(df,coluna)),test_vazio(df,coluna),0)
  cont_prob[coluna,"% Vazio"]  <- ifelse(is.numeric(test_vazio(df,coluna)),
                                        paste(round(((test_vazio(df,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_prob[coluna,"Zero"]  <- ifelse(is.numeric(test_zero(df,coluna)),test_zero(df,coluna),0)
  cont_prob[coluna,"% Zero"]  <- ifelse(is.numeric(test_zero(df,coluna)),
                                        paste(round(((test_zero(df,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
}

cont_prob <- cbind(cont_prob,tipo_dados)

cont_prob %>% kable(., format = "html",row.names = T, digits = 2) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive")) 
```

##### Avaliando os dados nulos

###### CAVA_RODA, ANGULO_FRiSO_RODA 

CAVA_RODA: A variável com maior número de dados nulos foi a CAVA_RODA com 607.049 (20%) dados nulos. Com o objetivo de avaliar a estratégia de tratamento dos dados vamos realizar a distribuição de dados nulos em comparação com as outras variáveis.

ANGULO_FRISO_RODA: A segunda variável com maior número de dados nulos foi a ANGULO_FRISO_RODA com 287.408 (10%) dados nulos em comparação as outras variáveis.

```{r}

# Avaliando os dados nulos para CAVA_RODA, indentificando se ocorreu alguma data com maior numero de dados nulos.

df_null_CAVA_RODA <- where(df, isNull(df$CAVA_RODA))

nulos_CAVA_RODA <- count(df_null_CAVA_RODA)

perc_nulos_CAVA_RODA <- paste(round((nulos_CAVA_RODA/total)*100,0),"%",sep="")

#perc_nulos_CAVA_RODA

# Avaliando os dados nulos para ANGULO_FRiSO_RODA, indentificando se ocorreu alguma data com maior numero de dados nulos.

df_null_ANGULO_FRISO_RODA <- where(df, isNull(df$ANGULO_FRISO_RODA))

nulos_ANGULO_FRISO_RODA <- count(df_null_ANGULO_FRISO_RODA)

perc_nulos_ANGULO_FRISO_RODA <- paste(round((nulos_ANGULO_FRISO_RODA/total)*100,0),"%",sep="")

#perc_nulos_ANGULO_FRISO_RODA

# O percentual de dados faltando para CAVA_RODA é de 20%

gb_df_null_CAVA_RODA <- groupBy(df_null_CAVA_RODA, df_null_CAVA_RODA$Dia)

nNull_CAVA_RODA_by_DIA <- agg(gb_df_null_CAVA_RODA, Nulls_CAVA_RODA = n(df_null_CAVA_RODA$Dia))

nNull_CAVA_RODA_by_DIA.dat <- collect(nNull_CAVA_RODA_by_DIA)
#nNull_CAVA_RODA_by_DIA.dat

CAVA_RODA_order_by_date <- nNull_CAVA_RODA_by_DIA.dat[order(nNull_CAVA_RODA_by_DIA.dat$Dia),]
#CAVA_RODA_order_by_date

# O percentual de dados faltando para ANGULO_FRISO_RODA é de 10%

gb_df_null_ANGULO_FRISO_RODA <- groupBy(df_null_ANGULO_FRISO_RODA, df_null_ANGULO_FRISO_RODA$Dia)

nNull_ANGULO_FRISO_RODA_by_DIA <- agg(gb_df_null_ANGULO_FRISO_RODA, 
                                      Nulls_ANGULO_FRISO_RODA = n(df_null_ANGULO_FRISO_RODA$Dia))

nNull_ANGULO_FRISO_RODA_by_DIA.dat <- collect(nNull_ANGULO_FRISO_RODA_by_DIA)
#nNull_ANGULO_FRISO_RODA_by_DIA.dat

ANGULO_FRISO_RODA_order_by_date <- nNull_ANGULO_FRISO_RODA_by_DIA.dat[order(nNull_ANGULO_FRISO_RODA_by_DIA.dat$Dia),]
#ANGULO_FRISO_RODA_order_by_date

full <- full_join(CAVA_RODA_order_by_date,
                  ANGULO_FRISO_RODA_order_by_date,
                  by = NULL)
#full

# Gráfico de Full

g_full <- ggplot(full, aes(x=Dia))+
  geom_line(aes(y=Nulls_CAVA_RODA),color="green")+
  geom_line(aes(y=Nulls_ANGULO_FRISO_RODA),color="red")+
  ggtitle("Nulos nas variáveis por dia")+
  xlab("Data (dias)")+
  ylab("Total de Nulos")+
  theme_dark()
g_full


```

Percebe-se um aumento significativo no número de dados núlos no final do período.

###### ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE, ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE, TRACKING_POSITION_EIXO_FRONTAL_TRUQUE, TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE, ROTACAO_EIXO, ALINHAMENTO_ENTRE_EIXOS_(IAM), DESLOCAMENTO_ENTRE_EIXOS_(SHIFT) e TRACKING_ERROR_(TE)

Essas variáveis apresentam 19.723 (1%) de valores nulos

```{r}

# Avaliando os dados nulos para CAVA_RODA, indentificando se ocorreu alguma data com maior numero de dados nulos.

variaveis <- c("ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE",
"ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE",
"TRACKING_POSITION_EIXO_FRONTAL_TRUQUE",
"TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE",
"ROTACAO_EIXO", 
"ALINHAMENTO_ENTRE_EIXOS_IAM", 
"DESLOCAMENTO_ENTRE_EIXOS_SHIFT", 
"TRACKING_ERROR_TE")

#ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE
# Avaliando os dados nulos para ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE, indentificando se ocorreu alguma data com maior numero de dados nulos.

df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE <- where(df, isNull(df$ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE))

nulos_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE <- count(df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE)

# O percentual de dados faltando para ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE é de 1%

gb_df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE <- groupBy(df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE, df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE$Dia)

nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA <- agg(gb_df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE, Nulls_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE = n(df_null_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE$Dia))

nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA.dat <- collect(nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA)
#nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA.dat

ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_order_by_date <- nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA.dat[order(nNull_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_by_DIA.dat$Dia),]
#ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_order_by_date

# Avaliando os dados nulos para ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE, indentificando se ocorreu alguma data com maior numero de dados nulos.

df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE <- where(df, isNull(df$ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE))

nulos_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE <- count(df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE)

# O percentual de dados faltando para ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE é de 20%

gb_df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE <- groupBy(df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE, df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE$Dia)

nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA <- agg(gb_df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE, Nulls_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE = n(df_null_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE$Dia))

nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA.dat <- collect(nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA)
#nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA.dat

ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_order_by_date <- nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA.dat[order(nNull_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_by_DIA.dat$Dia),]
#ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_order_by_date

# Avaliando os dados nulos para TRACKING_POSITION_EIXO_FRONTAL_TRUQUE, indentificando se ocorreu alguma data com maior numero de dados nulos.

df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE <- where(df, isNull(df$TRACKING_POSITION_EIXO_FRONTAL_TRUQUE))

# O percentual de dados faltando para TRACKING_POSITION_EIXO_FRONTAL_TRUQUE é de 20%

gb_df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE <- groupBy(df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE, df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE$Dia)

nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA <- agg(gb_df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE, Nulls_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE = n(df_null_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE$Dia))

nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA.dat <- collect(nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA)
#nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA.dat

TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_order_by_date <- nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA.dat[order(nNull_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_by_DIA.dat$Dia),]
#TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_order_by_date

full <- full_join(ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE_order_by_date,
                  ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE_order_by_date,
                  by = NULL)

full <- full_join(full,
                  TRACKING_POSITION_EIXO_FRONTAL_TRUQUE_order_by_date,
                  by= NULL)

g_full <- ggplot(full, aes(x=Dia))+
  geom_line(aes(y=Nulls_ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE),color="green")+
  geom_line(aes(y=Nulls_ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE),color="red")+
  geom_line(aes(y=Nulls_TRACKING_POSITION_EIXO_FRONTAL_TRUQUE),color="blue")+
  ggtitle("Nulos nas variáveis AAEFT, AAETT e TPEFT por dia")+
  xlab("Data (dias)")+
  ylab("Total de Nulos")+
  theme_dark()
g_full


```

Essas variaveis todas apresentaram um comportamento igual, ou seja, todas os casos nulos ocorreram no mesmo periodo

##### Realizando limpeza dos dados

```{r Davi 1}

#Limpando os dados nulos das colunas
#colnames(df)

dim(df)[1] %>% paste("Total de dados da base original ",.,sep="") %>% print()

# Retirando os dados nulos de CAVA_RODA (20.46% da base)
df_clean <- df %>% where(.,!isNull(.[[17]]))
# Retirando os dados nulos de ANGULO_FRISO_RODA (9.69% da base)
df_clean <- df_clean %>% where(.,!isNull(.[[14]]))
# Retirando os dados nulos de ESPESSURA_FRISO_RODA (0.05% da base)
df_clean <- df_clean %>% where(.,!isNull(.[[16]]))
# Retirando os dados nulos de ALTURA_FRISO_RODA (0.01% da base)
df_clean <- df_clean %>% where(.,!isNull(.[[15]]))
# Retirando os dados nulos de TRACKING_ERROR_(TE) (0.21% da base)
df_clean <- df_clean %>% where(.,!isNull(.[[25]]))

dim(df_clean)[1] %>% paste("Total de dados da base limpa ",.,sep="") %>% print()

# Redução dos dados
reduc <- round(((dim(df_clean)[1]/dim(df)[1])-1)*100,2) 
reduc <- paste("Redução dos dados de ",-reduc,"%",sep="")
print(reduc)

# Criando a coluna de tipo de dados
for (i in 1:length(colnames(df_clean))){
  x[i] <- dtypes(df_clean)[[i]][1]
  Tipo_de_dados[i] <- dtypes(df_clean)[[i]][2]
}
tipo_dados <- as.data.frame(Tipo_de_dados,x)

cont_clean <- data.frame()
for (coluna in colnames(df_clean)){

    cont_clean[coluna,"Nulo"]  <- ifelse(is.numeric(test_null(df_clean,coluna)),test_null(df_clean,coluna),0)
  cont_clean[coluna,"% Nulo"]  <- ifelse(is.numeric(test_null(df_clean,coluna)),
                                        paste(round(((test_null(df_clean,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_clean[coluna,"isNAN"] <-    ifelse(is.numeric(test_isNAN(df_clean,coluna)),test_isNAN(df_clean,coluna),0)
  cont_clean[coluna,"% isNAN"]  <- ifelse(is.numeric(test_isNAN(df_clean,coluna)),
                                        paste(round(((test_isNAN(df_clean,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_clean[coluna,"Vazio"] <- ifelse(is.numeric(test_vazio(df_clean,coluna)),test_vazio(df_clean,coluna),0)
  cont_clean[coluna,"% Vazio"]  <- ifelse(is.numeric(test_vazio(df_clean,coluna)),
                                        paste(round(((test_vazio(df_clean,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
  cont_clean[coluna,"Zero"]  <- ifelse(is.numeric(test_zero(df_clean,coluna)),test_zero(df_clean,coluna),0)
  cont_clean[coluna,"% Zero"]  <- ifelse(is.numeric(test_zero(df_clean,coluna)),
                                        paste(round(((test_zero(df_clean,coluna)/total)*100),2),"%",sep=""),
                                        "0%")
}

cont_clean <- cbind(cont_clean,tipo_dados)

cont_clean %>% kable(., format = "html",row.names = T, digits = 2) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive")) 
```

##### Dados agrupados por Data

```{r Davi 2}

sdf_date <-summarize(groupBy(df_clean, df_clean$Dia), count = n(df_clean$ROW_ID)) 

sdf_date <- collect(sdf_date)

sdf_date <- sdf_date[order(sdf_date$Dia),]


head(sdf_date)
g_date <- ggplot(sdf_date, aes(x=Dia))+
  geom_line(aes(y=count),color="green")+
  ggtitle("Qntd de dados dia")+
  xlab("Data (dias)")+
  ylab("Total de dados")+
  theme_dark()
g_date
```

##### Qtd de dados por CODIGO_VAGAO

```{r Davi 3}

sdf_CODIGO_VAGAO <-summarize(groupBy(df_clean, df_clean$CODIGO_VAGAO), count = n(df_clean$ROW_ID)) 

SparkR::head(arrange(sdf_CODIGO_VAGAO, desc(sdf_CODIGO_VAGAO$count)))

```


Criando planilha auxiliar para preparação dos dados
```{r Davi 4}

#Criando a planilha com as colunas relevantes
sdf_clean = select(df_clean, 
             df_clean$friso_baixo,
             df_clean$FRISO_MENOR_QUE_26,
             df_clean$ESPESSURA_FRISO_RODA,
             df_clean$CODIGO_VAGAO,
             df_clean$CODIGO_RODEIRO,
             df_clean$CODIGO_RODA,
             df_clean$LADO_RODA,
             df_clean$EIXO_VAGAO,
             df_clean$TRAIN_ID,
             df_clean$SENTIDO_TREM,
             df_clean$VELOCIDADE_ENTRADA_TREM,
             df_clean$VELOCIDADE_SAIDA_TREM,
             df_clean$POSICAO_VAGAO_COMPOSICAO,
             df_clean$ANGULO_FRISO_RODA,
             df_clean$ALTURA_FRISO_RODA,
             df_clean$CAVA_RODA,
             df_clean$ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE,
             df_clean$ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE,
             df_clean$TRACKING_POSITION_EIXO_FRONTAL_TRUQUE,
             df_clean$TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE,
             df_clean$ROTACAO_EIXO,
             df_clean$`ALINHAMENTO_ENTRE_EIXOS_(IAM)`,
             df_clean$`DESLOCAMENTO_ENTRE_EIXOS_(SHIFT)`,
             df_clean$`TRACKING_ERROR_(TE)`,
             df_clean$`SERPENTEAMENTO_(HUNTING)`)

#class(sdf_clean)
```

##### Qtd de dados por CODIGO_RODEIRO
##### Qtd de dados por CODIGO_RODA
##### Qtd de dados por EIXO_VAGAO
##### Qtd de dados por CICLO_RODEIRO
##### Qtd de dados por TRAIN_ID
##### Qtd de dados por SENTIDO_TREM

#### Identificar as principais estatisticas da Amostra

```{r Guilherme 2}
# Base Completa
#Listando apenas as colunas que são numéricas.
colunas_numeric <- cbind(coltypes(df),colnames(df)) %>%
as.data.frame %>%
dplyr::filter(.$V1=="numeric") %>%
dplyr::select(medidas=V2)


resumo_medidas <- data.frame()
resultado <- data.frame()

for (coluna in colunas_numeric$medidas){
#As colunas no dataframe são linhas neste relatório
#utilizando os dados de amostras (samples) para ser mais ágil.
resultado <- cbind(coluna,
df_sample %>% agg(.,
media = avg(.[[coluna]]),
desvio_padrao = sd(.[[coluna]]),
variancia = var(.[[coluna]]),
maximo = max(.[[coluna]]),
minimo = min(.[[coluna]])) %>%
as.data.frame())
resumo_medidas <- rbind(resumo_medidas,resultado)
}

#Print da tabela resumo.
resumo_medidas %>% kable(., format = "html",row.names = T, digits = 2) %>%
kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))


#Usando agg com agregação
# gb_sn <- groupBy(df_sample, df_sample$CODIGO_RODA)
# df2 <- agg(gb_sn, friso_avg = avg(df_sample$ESPESSURA_FRISO_RODA), count = n(df_sample$ESPESSURA_FRISO_RODA))
# head(df2)

```

#### Identificar as principais correlações entre os dados

```{r Davi 6}
# Medindo a correlação entre ESPESSURA FRISO RODA E EIXO VAGAO
corr_EFR_EV <- corr(sdf_clean, "ESPESSURA_FRISO_RODA", "EIXO_VAGAO")
corr_EFR_EV
```

#### Construir visualizações

Listados com top 10

```{r}

createOrReplaceTempView(df, "tabela")

sdf_vagao_trocas_roda <- sql("select
    CODIGO_VAGAO
    ,count(*) qtd

    from tabela
    where CODIGO_RODA != CICLO_RODEIRO
          and
          CODIGO_VAGAO in 
              (select
                  CODIGO_VAGAO
                      from tabela
                    where friso_baixo ==1
                    group by CODIGO_VAGAO)


    group by CODIGO_VAGAO
    order by qtd desc

    "
    
    )



sdf_vagao_trocas_roda_all <- sql(
"
  select
    *
  from
  tabela
  
  where CODIGO_VAGAO in
  (
  select
    CODIGO_VAGAO
    
      from tabela
    where CODIGO_RODA != CICLO_RODEIRO
          and
          CODIGO_VAGAO in 
              (select
                  CODIGO_VAGAO
                      from tabela
                    where friso_baixo ==1
                    group by CODIGO_VAGAO)


    group by CODIGO_VAGAO
  )
  
  "
)






lista_vagoes_troca_friso_baixo <- sdf_vagao_trocas_roda %>% head(1000)


vagoes <- lista_vagoes_troca_friso_baixo %>% head(10) %>% as.list()

myplots <- list()
n <- 1
for (vagao in vagoes$CODIGO_VAGAO){
  filtro_vagao <- vagao
  g1 <- 
    where(df,df$CODIGO_VAGAO==filtro_vagao)  %>%
    head(10000) %>%
    ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
    geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
    scale_y_continuous(limits = c(18,38))+
    geom_smooth()+
    geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
    theme(legend.position="none")
  
  myplots[[n]] <- g1
  n <- n+1
  print(g1)
}



# where(df,df$CODIGO_VAGAO=='69632')%>%
#   collect(.)%>%
#   ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
#   geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
#   scale_y_continuous(limits = c(18,38))+
#   geom_smooth()+
#   geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
#     theme(legend.position="none")



```

Listados com bottom 10

```{r}

vagoes <- lista_vagoes_troca_friso_baixo %>% tail(10) %>% as.list()

myplots <- list()
n <- 1
for (vagao in vagoes$CODIGO_VAGAO){
  filtro_vagao <- vagao
  g1 <- 
    where(df,df$CODIGO_VAGAO==filtro_vagao)  %>%
    head(10000) %>%
    ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
    geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
    scale_y_continuous(limits = c(18,38))+
    geom_smooth()+
    geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
    theme(legend.position="none")
  
  myplots[[n]] <- g1
  n <- n+1
  print(g1)
}


```

```{r Guilherme 1}
#Guilherme


```



```{r eval=FALSE, include=FALSE}
df_list <- randomSplit(sdf_clean, c(7,3), 2)
df_train <- df_list[[1]]
df_test <- df_list[[2]]

#model <- spark.glm(df_train, ESPESSURA_FRISO_RODA ~., family = "gaussian")

# df_list <- randomSplit(sdf, c(7,3), 2)
# df_train <- df_list[[1]]
# df_test <- df_list[[2]]
# 
# model <- spark.glm(df_train, GENDER ~., family = "gaussian")
# 
# summary(model)
# 
# predictions_1 <- predict(model, df_train)
# local_df <- collect(predictions_1)
# p = local_df$label-local_df$prediction
# mse = mean((p)^2)
# mae = mean(abs(p))
# rmse = sqrt(mse)
# R2 = 1-(sum((p)^2)/sum((local_df$label-mean(local_df$label))^2))
# print("Métricas de avaliação da base de Treino")
# sprintf(" MAE: %.2f", mae)
# sprintf("MSE: %.2f", mse)
# sprintf("RMSE: %.2f", rmse)
# sprintf("R2: %.4f", R2)

```




```{r}


#sdf_RODEIRO_friso_baixo_all  %>% 
#where(df,df$CODIGO_VAGAO=='515276') %>% 

sdf_vagao_trocas_roda_all %>% 
 collect(.) %>% 
 ggplot( aes(x=as.character(Dia), y=ESPESSURA_FRISO_RODA, fill=as.character(Dia))) +
   geom_boxplot() +
   scale_fill_viridis(discrete = TRUE, alpha=0.6) +
   geom_jitter(color="black", size=0.05, alpha=0.05) +
   theme(
     legend.position="none",
     plot.title = element_text(size=11)
   ) +
   #scale_y_continuous(limits = c(0,100))+
   ggtitle("ESPESSURA_FRISO_RODA Dia") +
   xlab("")



```


### Preparação dos Dados

#### Particionando os dados 70% para treino e 30% para teste

```{r Davi 7}
# Dividindo entre treino e teste

df_list <- randomSplit(sdf_clean, c(7,3),2)

df_train <- df_list[[1]]
df_test <- df_list[[2]]
```

```{r include=FALSE}

df_sample %>% where(.,isNull(.[["ANGULO_FRISO_RODA"]]))%>% head(100) 
df_sample %>% where(.,!isNull(.[["ANGULO_FRISO_RODA"]]))%>% head(100)

grupo_angulo_null <- groupBy(df %>% where(.,isNull(.[["ANGULO_FRISO_RODA"]])), df$CODIGO_RODA)
df2 <- agg(grupo_angulo_null,count = n(df$CODIGO_RODA))
df2 %>% head(1000)
#Algumas rodas nunca tiveram medidas de ângulo
#(5054164RIGHT,0960614RIGHT,6083714RIGHT,0995294RIGHT,5534531LEFT,5519574RIGHT,0867584RIGHT,6346311RIGHT,0809114RIGHT,5599823RIGHT)
# O que fazer nestes casos?


#Exemplo de rodas com falta de dados e uma opção de completar com fill.

cbind(
df %>% 
  where(.,df$CODIGO_RODA %in%
c('0956094RIGHT','6241133RIGHT','0851232RIGHT','7011773RIGHT','0825071RIGHT','5519574RIGHT','5392051LEFT','6395011LEFT','9126664LEFT')) %>% 
  select('Dia','CODIGO_RODA','ANGULO_FRISO_RODA') %>%  
  arrange('CODIGO_RODA','Dia') %>% 
  head(10000)
,

df %>% 
  where(.,df$CODIGO_RODA %in%
c('0956094RIGHT','6241133RIGHT','0851232RIGHT','7011773RIGHT','0825071RIGHT','5519574RIGHT','5392051LEFT','6395011LEFT','9126664LEFT')) %>% 
  arrange('CODIGO_RODA','Dia') %>% 
    select('ANGULO_FRISO_RODA') %>%  
  withColumnRenamed('ANGULO_FRISO_RODA','downup') %>% 
  head(10000) %>% 
  fill('downup', .direction = "downup")

,

df %>% 
  where(.,df$CODIGO_RODA %in%
c('0956094RIGHT','6241133RIGHT','0851232RIGHT','7011773RIGHT','0825071RIGHT','5519574RIGHT','5392051LEFT','6395011LEFT','9126664LEFT')) %>% 
  arrange('CODIGO_RODA','Dia') %>% 
    select('ANGULO_FRISO_RODA') %>%   
  withColumnRenamed('ANGULO_FRISO_RODA','up') %>% 
  head(10000) %>% 
  fill('up', .direction = "up")



,

df %>% 
  where(.,df$CODIGO_RODA %in%
c('0956094RIGHT','6241133RIGHT','0851232RIGHT','7011773RIGHT','0825071RIGHT','5519574RIGHT','5392051LEFT','6395011LEFT','9126664LEFT')) %>% 
  arrange('CODIGO_RODA','Dia') %>% 
    select('ANGULO_FRISO_RODA') %>%  
  withColumnRenamed('ANGULO_FRISO_RODA','down') %>% 
  head(10000) %>% 
  fill('down', .direction = "down")


)



df_sample %>% where(.,isNull(.[["ALTURA_FRISO_RODA"]]))%>% head(100) 
df_sample %>% where(.,isNull(.[["ESPESSURA_FRISO_RODA"]]))%>% head(100)
df_sample %>% where(.,isNull(.[["CAVA_RODA"]]))%>% head(100)



# As medidas do TBOGIE parecem falhar pelo mesma razão para todas as medidas.

# ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE       
# ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE      
# TRACKING_POSITION_EIXO_FRONTAL_TRUQUE   
# ROTACAO_EIXO                            
# ALINHAMENTO_ENTRE_EIXOS_(IAM)           
# DESLOCAMENTO_ENTRE_EIXOS_(SHIFT)        
# TRACKING_ERROR_(TE)                     
# SERPENTEAMENTO_(HUNTING)  

#df_sample %>% where(.,isNaN(.[["ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE"]])) %>% head(100) %>% View()
#df_sample %>% where(.,.[["ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE"]]== "")  %>% head(100) %>% View()
#df_sample %>% where(.,.[["ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE"]]== 0)  %>% head(100) %>% View()


```


#### PCA/Redução de dimensionalidade

### Modelagem

#### Classificação

##### Regressão logística

```{r Davi 8, cache=TRUE}
# Modelo básico de regreção logística
#head(df_train)
colnames(df_train)

model <- spark.logit(df_train, FRISO_MENOR_QUE_26 ~ 
                       VELOCIDADE_ENTRADA_TREM+
                       VELOCIDADE_SAIDA_TREM+
                       VELOCIDADE_ENTRADA_TREM+
                       POSICAO_VAGAO_COMPOSICAO+
                       ANGULO_FRISO_RODA+
                       CAVA_RODA
                       #ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE+
                       #ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE+
                       #TRACKING_POSITION_EIXO_FRONTAL_TRUQUE+
                       #TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE+
                       #ROTACAO_EIXO+
                       #ALINHAMENTO_ENTRE_EIXOS_(IAM)+
                       #DESLOCAMENTO_ENTRE_EIXOS_(SHIFT)+
                       #TRACKING_ERROR_(TE)+
                       #SERPENTEAMENTO_(HUNTING)
                     ,
                     regParam = 0.5)

summary <- summary(model)
summary
```

##### Árvore de decisão

```{r Davi 10}
model <- spark.randomForest(df_train, FRISO_MENOR_QUE_26 ~ 
                              VELOCIDADE_ENTRADA_TREM, 
                            "classification", numTrees = 5)
summary <- summary(model)

```

##### Redes neurais
##### Ensemble?

### Avaliação

#### Regressão logística

```{r Davi 9, cache=TRUE}
# Modelo básico de regreção logística
fitted <- predict(model, df_test)

createOrReplaceTempView(fitted, "predictions")

correct <- sql("SELECT prediction, FRISO_MENOR_QUE_26 FROM predictions WHERE prediction=FRISO_MENOR_QUE_26")
head(correct)

acc = count(correct)/count(fitted)
acc
```

```{r Davi 11, cache=TRUE}
fitted <- predict(model, df_test)

createOrReplaceTempView(fitted, "predictions")
correct <- sql("SELECT prediction, FRISO_MENOR_QUE_26 FROM predictions WHERE prediction=FRISO_MENOR_QUE_26")
acc = count(correct)/count(fitted)
acc

```

### Conclusão

