---
title: "Desafios e Requisitos dos Projetos Analiticos"
authores: "Davi Almeida Ferreira e Guilherme Rocha Gomez"
date: "Julho de 2021"
output:
  html_document:
        code_folding: hide
        number_sections: no
        toc: yes
        toc_float:
            collapsed: yes
            smooth_scroll: yes
---
<left>

![](simbolo_fgv.png)

Turma: **FGV TBABD-8**  
Professor: **Rafael Lychowski**  
Autores: **Davi Almeida Ferreira** e **Guilherme Rocha Gomez** 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 10, warning = F, error = F)
```


### Metodologia utilizada

Utilizaremos para a realização deste trabalho a metodologia CRISP-DM

<center>

![](crisp-dm.png)

### Entendimento do Negócio

A Vale pretende prever o desgaste de rodas de vagões e fornecer uma visão futura da frota de rodeiros, para melhor planejamento de menutanção e compra de componentes. 

**Problema:** Prever se o friso da roda estaá abaixo de 26 mm na próxima leitura.

1. A área não tem visibilidade do que vai contecer com o ativos, antecipando as trocas;
2. A cada troca o rodeiro é usinado, e sua vida útil reduzida;
3. Incapacidade de visuzalização de desgastes acelerados em toda a frota de vagões
4. Muitos vagões apresentam reinciência de trocas, e os fatores não são bem claros;

* Base de dados: EFC_WAYSIDES.csv
* Variável dependente: ESPESSURA_FRISO_RODA
* Método: Supervisionado
* Submétodo: Classificação
* Objetivo: Identificar quais os frisos terão menos que 26 cm de friso no próximo ciclo.

### Entendimento dos Dados

```{r include=FALSE}
# Importar bibliotecas que serão utilizadas no trabalho

library(caret)
library(mlbench)
library(dplyr)
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(hrbrthemes)
library(viridis)

# Iniciar sessão do SPARK

aluno <- "Guilherme"
#aluno <- "Davi"

if (aluno == "Guilherme") {
library(SparkR, lib.loc = c(file.path(Sys.getenv("SPARK_HOME"), "R", "lib")))
  
spark_path <-'C:/Guilherme/spark'
if (nchar(Sys.getenv("SPARK_HOME")) < 1) {
  Sys.setenv(SPARK_HOME = spark_path)
}
sparkR.session(master = "local[*]", sparkConfig = 
list(spark.driver.memory = "1g"))

pathfile = "C:/Guilherme/FGV/Desafios e Requisitos dos Projetos Analiticos/EFC_WAYSIDES.csv"

}else{

library(SparkR)

spark_path <-"C:/spark-3.1.2-bin-hadoop3.2"
if (nchar(Sys.getenv("SPARK_HOME")) < 1) {
  Sys.setenv(SPARK_HOME = spark_path)
}
sparkR.session(master = "local[*]", sparkConfig = list(spark.driver.memory = "6g"))

pathfile <- "C:/trabalho-final-desafios/EFC_WAYSIDES.csv"
}

paste("Configuração para o computador do: ",aluno)

sqlContext <- sparkR.session(sc)
sparkR.conf()

```

```{r include=FALSE}
# Importar dataset 

# Utilizando o inferSchema muitos campos numéricos foram identificados com string.
schema <- structType(
  structField("ROW_ID", "string"),
  structField("DATA_HORA_LEITURA", "timestamp"),
  structField("CODIGO_VAGAO", "string"),
  structField("CODIGO_RODEIRO", "string"),
  structField("CODIGO_RODA", "string"),
  structField("LADO_RODA", "string"),
  structField("EIXO_VAGAO", "double"),
  structField("CICLO_RODEIRO", "string"),
  structField("TRAIN_ID", "string"),
  structField("SENTIDO_TREM", "string"),
  structField("VELOCIDADE_ENTRADA_TREM", "double"),
  structField("VELOCIDADE_SAIDA_TREM", "double"),
  structField("POSICAO_VAGAO_COMPOSICAO", "double"),
  structField("ANGULO_FRISO_RODA", "double"),
  structField("ALTURA_FRISO_RODA", "double"),
  structField("ESPESSURA_FRISO_RODA", "double"),
  structField("CAVA_RODA", "double"),
  structField("ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE", "double"),
  structField("ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE", "double"),
  structField("TRACKING_POSITION_EIXO_FRONTAL_TRUQUE", "double"),
  structField("TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE", "double"),
  structField("ROTACAO_EIXO", "double"),
  structField("ALINHAMENTO_ENTRE_EIXOS_(IAM)", "double"),
  structField("DESLOCAMENTO_ENTRE_EIXOS_(SHIFT)", "double"),
  structField("TRACKING_ERROR_(TE)", "double"),
  structField("SERPENTEAMENTO_(HUNTING)", "double"),
  structField("friso_baixo", "double")
)

df <- SparkR::read.df(path = pathfile,
                      header='true', 
                      source = "com.databricks.spark.csv", 
                      schema = schema,
                      na.strings = "")

head(df)
cache(df)


#Criando novas colunas pelo método mais comum.
df$friso_baixo <- SparkR::ifelse(df$ESPESSURA_FRISO_RODA<26,1,0)

#Criando novas colunas e escolhendo o tipo de dado usanod withColumn.
df <- df %>% 
  withColumn(.,"Dia",cast(df$DATA_HORA_LEITURA,"Date")) #%>% 
  #withColumn(.,"Dia",cast(df$DATA_HORA_LEITURA,"Date"))


df_sample <- df %>% sample(withReplacement = F,fraction = 0.0005)

#read.df(sqlContext,)

# Incluir o arquivo na memória para facilitar a interação
persist(df,"MEMORY_ONLY")

#cache(df) == persist(df,"MEMORY_ONLY")
#cacheTable(sqlContext,"tableNmae")

```

#### Verificação da qualidade dos Dados

```{r}
"Verificando o 'Schema' dos dados"
printSchema(df)

```

##### Verificar a existencia de dados faltantes

Foi verificado que nenhuma variável possui valores faltantes (Null, NaN, etc). Algumas variáveis possuem tipo incorreto ao apresentado na proposição do problema.

```{r include=FALSE}

#Visualizando uma amostra de dados
SparkR::head(df,32)
#dtypes(df)

#Verificando valores faltantes no df
ncol_df <- ncol(df)
ncol_df

columns(df)
col_name <- 0
is_Null <- 0
col_class <- 0

```

```{r, cache=TRUE}

# n <- 1
# for (coluna in colnames(df)){
#   cont_prob["nulo",coluna] <- cbind(coluna,
#   df %>% where(., isNull(.[[coluna]])) %>% count(.)
#   )
#   #df %>% where(., isNull(paste0(".$",coluna))) %>% count(.)
#   n <- n+1
# }


test_null <- function(coluna){
   try(df %>% where(.,isNull(.[[coluna]]))%>%count(.), silent = TRUE)
}


test_isNAN <- function(coluna){
  try(df %>% where(.,isNaN(.[[coluna]]))%>%count(.), silent = TRUE)
}


test_vazio <- function(coluna){
  try(df %>% where(.,.[[coluna]]== "")  %>% count(.), silent = TRUE)
}
 

test_zero <- function(coluna){
  try(df %>% where(.,.[[coluna]]== 0)  %>% count(.), silent = TRUE)
}


cont_prob <- data.frame()
for (coluna in colnames(df)){
  
  cont_prob["nulo",coluna]  <- test_null(coluna)
  cont_prob["isNAN",coluna] <- test_isNAN(coluna)
  cont_prob["vazio",coluna] <- test_vazio(coluna)
  cont_prob["zero",coluna]  <- test_zero(coluna)
  
  print(coluna)
  
}
cont_prob <- t(cont_prob) %>% as.data.frame()

#Removendo os valores com erros (Texto).
cont_prob[which(grepl(",",cont_prob[,1])),1] <- 0
cont_prob[which(grepl(",",cont_prob[,2])),2] <- 0
cont_prob[which(grepl(",",cont_prob[,3])),3] <- 0
cont_prob[which(grepl(",",cont_prob[,4])),4] <- 0

cont_prob %>% kable(., format = "html",row.names = T, digits = 2) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive")) 

```


#### Identificar as principais estatisticas da Amostra


```{r}
sumstats1 <- describe(df, "EIXO_VAGAO",
                     "VELOCIDADE_ENTRADA_TREM",
                     "VELOCIDADE_SAIDA_TREM")
sumstats2 <- describe(df, "POSICAO_VAGAO_COMPOSICAO",
                     "ANGULO_FRISO_RODA",
                     "ALTURA_FRISO_RODA")
sumstats3 <- describe(df, "ESPESSURA_FRISO_RODA",
                     "CAVA_RODA",
                     "ROTACAO_EIXO")
sumstats4 <- describe(df, "ANGULO_ATAQUE_EIXO_FRONTAL_TRUQUE",
                     "ANGULO_ATAQUE_EIXO_TRASEIRO_TRUQUE")
sumstats5 <- describe(df, "TRACKING_POSITION_EIXO_FRONTAL_TRUQUE")
sumstats6 <- describe(df, "TRACKING_POSITION_EIXO_TRASEIRO_TRUQUE")
showDF(sumstats1)
showDF(sumstats2)
showDF(sumstats3)
showDF(sumstats4)
showDF(sumstats5)
showDF(sumstats6)
```


```{r echo=FALSE}
#Usando a função agg

agg(df, velo_entrada_avg = avg(df$VELOCIDADE_ENTRADA_TREM)) %>% head()
agg(df, velo_entrada_sd = sd(df$VELOCIDADE_ENTRADA_TREM)) %>% head()
agg(df, velo_entrada_var = var(df$VELOCIDADE_ENTRADA_TREM)) %>% head()
agg(df, velo_entrada_max = max(df$VELOCIDADE_ENTRADA_TREM)) %>% head()

agg(df, alt_friso_avg = avg(df$ESPESSURA_FRISO_RODA)) %>% head()
agg(df, alt_friso_sd = sd(df$ESPESSURA_FRISO_RODA)) %>% head()
agg(df, alt_friso_var = var(df$ESPESSURA_FRISO_RODA)) %>% head()
agg(df, alt_friso_max = max(df$ESPESSURA_FRISO_RODA)) %>% head()


#Usando agg com agregação
gb_sn <- groupBy(df, df$CODIGO_RODA)
df2 <- agg(gb_sn, friso_avg = avg(df$ESPESSURA_FRISO_RODA), count = n(df$ESPESSURA_FRISO_RODA))
head(df2)


```


#### Identificar as principais correlações entre os dados

```{r}
# Medindo a correlação entre ESPESSURA FRISO RODA E EIXO VAGAO
corr_EFR_EV <- corr(df, "ESPESSURA_FRISO_RODA", "EIXO_VAGAO")
corr_EFR_EV


```

#### Construir visualizações

Listados com top 10

```{r}

createOrReplaceTempView(df, "tabela")

sdf_vagao_trocas_roda <- sql("select
    CODIGO_VAGAO
    ,count(*) qtd

    from tabela
    where CODIGO_RODA != CICLO_RODEIRO
          and
          CODIGO_VAGAO in 
              (select
                  CODIGO_VAGAO
                      from tabela
                    where friso_baixo ==1
                    group by CODIGO_VAGAO)


    group by CODIGO_VAGAO
    order by qtd desc

    "
    
    )



sdf_vagao_trocas_roda_all <- sql(
"
  select
    *
  from
  tabela
  
  where CODIGO_VAGAO in
  (
  select
    CODIGO_VAGAO
    
      from tabela
    where CODIGO_RODA != CICLO_RODEIRO
          and
          CODIGO_VAGAO in 
              (select
                  CODIGO_VAGAO
                      from tabela
                    where friso_baixo ==1
                    group by CODIGO_VAGAO)


    group by CODIGO_VAGAO
  )
  
  "
)






lista_vagoes_troca_friso_baixo <- sdf_vagao_trocas_roda %>% head(1000)


vagoes <- lista_vagoes_troca_friso_baixo %>% head(10) %>% as.list()

myplots <- list()
n <- 1
for (vagao in vagoes$CODIGO_VAGAO){
  filtro_vagao <- vagao
  g1 <- 
    where(df,df$CODIGO_VAGAO==filtro_vagao)  %>%
    head(10000) %>%
    ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
    geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
    scale_y_continuous(limits = c(18,38))+
    geom_smooth()+
    geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
    theme(legend.position="none")
  
  myplots[[n]] <- g1
  n <- n+1
  print(g1)
}



# where(df,df$CODIGO_VAGAO=='69632')%>%
#   collect(.)%>%
#   ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
#   geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
#   scale_y_continuous(limits = c(18,38))+
#   geom_smooth()+
#   geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
#     theme(legend.position="none")



```

Listados com bottom 10

```{r}

vagoes <- lista_vagoes_troca_friso_baixo %>% tail(10) %>% as.list()

myplots <- list()
n <- 1
for (vagao in vagoes$CODIGO_VAGAO){
  filtro_vagao <- vagao
  g1 <- 
    where(df,df$CODIGO_VAGAO==filtro_vagao)  %>%
    head(10000) %>%
    ggplot(aes(x=Dia, y=ESPESSURA_FRISO_RODA,color=CICLO_RODEIRO))+
    geom_point()+facet_wrap(~CODIGO_RODA,ncol = 2)+
    scale_y_continuous(limits = c(18,38))+
    geom_smooth()+
    geom_hline(yintercept=26, linetype="dashed", color = "red", size=1)+
    theme(legend.position="none")
  
  myplots[[n]] <- g1
  n <- n+1
  print(g1)
}


```






```{r eval=FALSE, include=FALSE}
df_list <- randomSplit(sdf, c(7,3), 2)
df_train <- df_list[[1]]
df_test <- df_list[[2]]

#model <- spark.glm(df_train, ESPESSURA_FRISO_RODA ~., family = "gaussian")

# df_list <- randomSplit(sdf, c(7,3), 2)
# df_train <- df_list[[1]]
# df_test <- df_list[[2]]
# 
# model <- spark.glm(df_train, GENDER ~., family = "gaussian")
# 
# summary(model)
# 
# predictions_1 <- predict(model, df_train)
# local_df <- collect(predictions_1)
# p = local_df$label-local_df$prediction
# mse = mean((p)^2)
# mae = mean(abs(p))
# rmse = sqrt(mse)
# R2 = 1-(sum((p)^2)/sum((local_df$label-mean(local_df$label))^2))
# print("Métricas de avaliação da base de Treino")
# sprintf(" MAE: %.2f", mae)
# sprintf("MSE: %.2f", mse)
# sprintf("RMSE: %.2f", rmse)
# sprintf("R2: %.4f", R2)

```




```{r}


#sdf_RODEIRO_friso_baixo_all  %>% 
#where(df,df$CODIGO_VAGAO=='515276') %>% 

sdf_vagao_trocas_roda_all %>% 
 collect(.) %>% 
 ggplot( aes(x=as.character(Dia), y=ESPESSURA_FRISO_RODA, fill=as.character(Dia))) +
   geom_boxplot() +
   scale_fill_viridis(discrete = TRUE, alpha=0.6) +
   geom_jitter(color="black", size=0.05, alpha=0.05) +
   theme(
     legend.position="none",
     plot.title = element_text(size=11)
   ) +
   #scale_y_continuous(limits = c(0,100))+
   ggtitle("ESPESSURA_FRISO_RODA Dia") +
   xlab("")



```


```{r}



```


### Preparação dos Dados

#### Normalizaçao?
#### PCA/Redução de dimensionalidade

### Modelagem

#### Classificação
##### Regressão logística
##### Árvore de decisão
##### Redes neurais
##### Ensemble?

### Avaliação

### Conclusão

